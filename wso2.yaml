package:
  name: wso2
  # IMPORTANT - Manual updates required between versions. Please refer to the
  # vars section below.
  version: 7.1.0
  epoch: 0
  description: "WSO2 Identity Server - Open source identity and access management solution"
  copyright:
    # https://github.com/chainguard-dev/image-requests/issues/5594#issuecomment-2992353956
    - license: Apache-2.0
  dependencies:
    runtime:
      - busybox
      - ca-certificates-bundle
      - netcat-openbsd
      - openjdk-${{vars.runtime-java-version}}-default-jvm
      - tzdata

vars:
  # --- Manual update required, docker-entrypoint vars ---
  # This application depends on docker-entrypoint scripts, which are contained
  # in a different repository. The tagging format is also slightly different.
  # Whilst releases are not frequent, for each new-version update, please check
  # what the 'closest' corresponding release tag is here, then update below:
  # - https://github.com/wso2/docker-is
  docker-entrypoint-git-repo-tag: v7.1.0.1
  docker-entrypoint-git-repo-sha: 5c550233f4dd0517576d223b3d50ee4c639699c0
  java-version: 11
  runtime-java-version: 21

environment:
  contents:
    packages:
      - busybox
      - maven
      - openjdk-${{vars.java-version}}-default-jdk
      - zip
  environment:
    JAVA_HOME: /usr/lib/jvm/java-${{vars.java-version}}-openjdk
    # Required for compatibility with older JAR files in Maven dependencies that don't follow strict ZIP specifications
    JAVA_TOOL_OPTIONS: "-Djdk.util.zip.disableZip64ExtraFieldValidation=true -Djdk.nio.zipfs.allowDotZipEntry=true"
    MAVEN_OPTS: |
      -Xmx2g
      -Dmaven.artifact.threads=10

pipeline:
  - uses: git-checkout
    with:
      repository: https://github.com/wso2/product-is
      tag: v${{package.version}}
      expected-commit: d1738c763163b0df2722be27eac65e5a7470b02a

  - uses: git-checkout
    with:
      repository: https://github.com/wso2/docker-is
      tag: ${{vars.docker-entrypoint-git-repo-tag}}
      expected-commit: ${{vars.docker-entrypoint-git-repo-sha}}
      destination: docker-is

  - runs: |
      # Build all modules from the root
      mvn clean install -Dmaven.test.skip=true

  - runs: |
      # Create installation directory structure
      mkdir -p ${{targets.destdir}}/usr/share/java/wso2is
      mkdir -p ${{targets.destdir}}/usr/bin
      mkdir -p ${{targets.destdir}}/var/lib/wso2is
      mkdir -p ${{targets.destdir}}/var/log/wso2is

      # Install from distribution ZIP
      unzip -q modules/distribution/target/wso2is-${{package.version}}.zip -d modules/distribution/target/
      cp -r modules/distribution/target/wso2is-${{package.version}}/* ${{targets.destdir}}/usr/share/java/wso2is/
      chmod +x ${{targets.destdir}}/usr/share/java/wso2is/bin/*.sh 2>/dev/null

      # Create symlinks for data and logs
      ln -sf /var/lib/wso2is ${{targets.destdir}}/usr/share/java/wso2is/repository/database
      ln -sf /var/log/wso2is ${{targets.destdir}}/usr/share/java/wso2is/repository/logs

      # Copy docker-entrypoint.sh from the docker-is repository
      cp docker-is/dockerfiles/alpine/is/docker-entrypoint.sh ${{targets.destdir}}/usr/share/java/wso2is/
      chmod +x ${{targets.destdir}}/usr/share/java/wso2is/docker-entrypoint.sh

      # Make all scripts executable
      chmod +x ${{targets.destdir}}/usr/share/java/wso2is/bin/*.sh

subpackages:
  - name: ${{package.name}}-compat
    description: "Compatibility package for WSO2 Identity Server Docker deployments"
    pipeline:
      - runs: |
          mkdir -p ${{targets.destdir}}/home/wso2carbon

          # Create symlink for WSO2 IS directory where Docker expects it
          ln -sf /usr/share/java/wso2is ${{targets.destdir}}/home/wso2carbon/wso2is-${{package.version}}

          # Create symlinks for Docker scripts
          mkdir -p ${{targets.destdir}}/
          ln -sf /usr/share/java/wso2is/bin/wso2server.sh ${{targets.destdir}}/wso2server.sh
          ln -sf /usr/share/java/wso2is/docker-entrypoint.sh ${{targets.destdir}}/home/wso2carbon/docker-entrypoint.sh
          ln -sf /usr/share/java/wso2is/docker-entrypoint.sh ${{targets.destdir}}/docker-entrypoint.sh

          # Create Java preferences directories
          mkdir -p ${{targets.destdir}}/home/wso2carbon/.java/.systemPrefs
          mkdir -p ${{targets.destdir}}/home/wso2carbon/.java/.userPrefs
    test:
      environment:
        contents:
          packages:
            - ${{package.name}}
      pipeline:
        - name: Test root-level symlinks
          runs: |
            stat /home/wso2carbon/wso2is-${{package.version}}/README.txt
            stat /wso2server.sh
            stat /home/wso2carbon/docker-entrypoint.sh
            stat /docker-entrypoint.sh
            stat /home/wso2carbon/.java/.systemPrefs
            stat /home/wso2carbon/.java/.userPrefs

  - name: ${{package.name}}-doc
    description: "Documentation for WSO2 Identity Server"
    pipeline:
      - uses: split/manpages

test:
  environment:
    contents:
      packages:
        - ${{package.name}}-compat
        - curl
        - openjdk-${{vars.runtime-java-version}}-default-jvm
        - procps
        - wait-for-it
    environment:
      JAVA_HOME: "/usr/lib/jvm/default-jvm"
      CARBON_HOME: "/usr/share/java/wso2is"
  pipeline:
    - name: Check installation
      runs: |
        # Verify installation directories
        stat /usr/share/java/wso2is
        stat /usr/share/java/wso2is/bin/wso2server.sh
    - name: Test Startup
      runs: |
        # Set up environment as Docker would
        export WORKING_DIRECTORY="/home/wso2carbon"
        export WSO2_SERVER_HOME="/usr/share/java/wso2is"

        # Start using docker-entrypoint.sh
        # Also validates the symlink created by our -compat package.
        /home/wso2carbon/docker-entrypoint.sh > /tmp/wso2is.log 2>&1 &
        SERVER_PID=$!
        sleep 5
        if ! ps -p $SERVER_PID > /dev/null 2>&1; then
          echo "Failed to launch application via docker-entrypoint.sh"
          exit 1
        fi

        echo "Waiting for server to start..."
        wait-for-it localhost:9443 --timeout=90
    - name: Test creating a new user via SCIM API
      runs: |
        # Create a test user via SCIM
        CREATE_RESPONSE=$(curl -k -s -u "admin:admin" -w "\n%{http_code}" \
          -H "Content-Type: application/json" \
          -d '{
            "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
            "userName": "testuser123",
            "password": "Test@123",
            "name": {
              "givenName": "Test",
              "familyName": "User"
            },
            "emails": [{
              "primary": true,
              "value": "testuser@example.com"
            }]
          }' \
          "https://localhost:9443/scim2/Users" 2>/dev/null)

        CREATE_CODE=$(echo "$CREATE_RESPONSE" | tail -1)
        if [ "$CREATE_CODE" != "201" ]; then
          echo "Failed to create SCIM user - HTTP $CREATE_CODE"
          echo "Response: $(echo "$CREATE_RESPONSE" | head -n -1)"; exit 1
        fi

        # List users and verify our test user exists
        LIST_RESPONSE=$(curl -k -s -u "admin:admin" -w "\n%{http_code}" \
          "https://localhost:9443/scim2/Users?filter=userName+eq+testuser123" 2>/dev/null)

        LIST_CODE=$(echo "$LIST_RESPONSE" | tail -1)
        LIST_BODY=$(echo "$LIST_RESPONSE" | head -n -1)

        if [ "$LIST_CODE" != "200" ]; then
          echo "SCIM API returned non-200 response fetching users: $LIST_CODE"; exit 1
        fi

        # Verify the 'testuser' was returned in the results
        if ! echo "$LIST_BODY" | grep -q '"userName".*"testuser123"'; then
          echo "SCIM API test failed - 'testuser123' not found in response: $LIST_BODY"; exit 1
        fi
    - name: Test OAuth2 endpoints
      runs: |
        RESPONSE=$(curl -k -s -w "\n%{http_code}" "https://localhost:9443/oauth2/oidcdiscovery/.well-known/openid-configuration" 2>/dev/null)
        HTTP_CODE=$(echo "$RESPONSE" | tail -1)
        BODY=$(echo "$RESPONSE" | head -n -1)

        if [ "$HTTP_CODE" != "200" ]; then
          echo "OAuth2 endpoint returned HTTP $HTTP_CODE"; exit 1
        fi

        # Verify it's a valid OIDC discovery document with required fields
        if ! echo "$BODY" | grep -q '"issuer".*"https://localhost:9443/oauth2/token"'; then
          echo "OAuth2 discovery missing valid issuer"; exit 1
        fi

        if ! echo "$BODY" | grep -q '"authorization_endpoint"'; then
          echo "OAuth2 discovery missing authorization_endpoint"; exit 1
        fi
    - name: Test management console
      runs: |
        # Get both status code and content
        RESPONSE=$(curl -k -L -s -w "\n%{http_code}" "https://localhost:9443/carbon" 2>/dev/null)
        HTTP_CODE=$(echo "$RESPONSE" | tail -1)
        BODY=$(echo "$RESPONSE" | head -n -1)

        if [ "$HTTP_CODE" != "200" ]; then
          echo "Management console returned HTTP $HTTP_CODE"; exit 1
        fi

        # Verify we got the WSO2 Management Console login page
        if ! echo "$BODY" | grep -q "<title>WSO2 Management Console</title>"; then
          echo "Management console response missing expected title"; exit 1
        fi

        # Verify login form is present
        if ! echo "$BODY" | grep -q "txtUserName"; then
          echo "Management console login form not found"; exit 1
        fi

        # Verify it's the Carbon admin console
        if ! echo "$BODY" | grep -q "/carbon/admin/login_action.jsp"; then
          echo "Management console not pointing to correct login action"; exit 1
        fi
    - name: Test SAML SSO metadata
      runs: |
        RESPONSE=$(curl -k -s -w "\n%{http_code}" "https://localhost:9443/identity/metadata/saml2" 2>/dev/null)
        HTTP_CODE=$(echo "$RESPONSE" | tail -1)
        BODY=$(echo "$RESPONSE" | head -n -1)

        if [ "$HTTP_CODE" != "200" ]; then
          echo "SAML metadata endpoint returned HTTP $HTTP_CODE"; exit 1
        fi

        if ! echo "$BODY" | grep -q "EntityDescriptor"; then
          echo "SAML metadata response missing EntityDescriptor element"; exit 1
        fi
    - name: Test OAuth2 and OpenID Connect flow
      runs: |
        # Step 1: Register a new OAuth2 client via Dynamic Client Registration
        CLIENT_RESPONSE=$(curl -k -s -u "admin:admin" -X POST \
          -H "Content-Type: application/json" \
          -d '{
            "client_name": "test_client",
            "grant_types": ["password"],
            "redirect_uris": ["http://localhost"]
          }' \
          "https://localhost:9443/api/identity/oauth2/dcr/v1.1/register" 2>/dev/null)

        CLIENT_ID=$(echo "$CLIENT_RESPONSE" | grep -o '"client_id":"[^"]*"' | cut -d'"' -f4)
        CLIENT_SECRET=$(echo "$CLIENT_RESPONSE" | grep -o '"client_secret":"[^"]*"' | cut -d'"' -f4)

        if [ -z "$CLIENT_ID" ] || [ -z "$CLIENT_SECRET" ]; then
          echo "Failed to register OAuth client"
          echo "Response: $CLIENT_RESPONSE"; exit 1
        fi

        # Step 2: Get access token and ID token using the registered client
        TOKEN_RESPONSE=$(curl -k -s -X POST \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -u "$CLIENT_ID:$CLIENT_SECRET" \
          -d "grant_type=password&username=admin&password=admin&scope=openid internal_login" \
          "https://localhost:9443/oauth2/token" 2>/dev/null)

        ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
        ID_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"id_token":"[^"]*"' | cut -d'"' -f4)

        if [ -z "$ACCESS_TOKEN" ]; then
          echo "Failed to get access token"
          echo "Response: $TOKEN_RESPONSE"; exit 1
        fi

        # Step 3: Verify OpenID Connect is working (ID token must be present)
        if [ -z "$ID_TOKEN" ]; then
          echo "No ID token in response - OpenID Connect not working"
          echo "Response: $TOKEN_RESPONSE"; exit 1
        fi

        # Test OAuth userinfo endpoint
        echo "Testing OAuth userinfo endpoint..."
        RESPONSE=$(curl -k -s -H "Authorization: Bearer $ACCESS_TOKEN" \
          -w "\n%{http_code}" \
          "https://localhost:9443/oauth2/userinfo" 2>/dev/null)

        HTTP_CODE=$(echo "$RESPONSE" | tail -1)
        BODY=$(echo "$RESPONSE" | head -n -1)

        if [ "$HTTP_CODE" = "200" ]; then
          echo "Userinfo endpoint accessible with OAuth (HTTP 200)"
          USERNAME=$(echo "$BODY" | grep -o '"sub":"[^"]*"' | cut -d'"' -f4)
          if [ -n "$USERNAME" ]; then
            echo "  User: $USERNAME"
          fi
        else
          echo "Userinfo endpoint returned HTTP $HTTP_CODE"
          echo "  Response: $BODY"
          exit 1
        fi

        # Test JWKS endpoint (for token verification)
        echo "Testing JWKS endpoint..."
        RESPONSE=$(curl -k -s -w "\n%{http_code}" \
          "https://localhost:9443/oauth2/jwks" 2>/dev/null)

        HTTP_CODE=$(echo "$RESPONSE" | tail -1)
        if [ "$HTTP_CODE" = "200" ]; then
          echo "JWKS endpoint accessible (HTTP 200)"
          KEYS=$(echo "$RESPONSE" | head -n -1 | grep -o '"kid"' | wc -l)
          echo "  Found $KEYS signing keys"
        else
          echo "JWKS endpoint returned HTTP $HTTP_CODE"
          exit 1
        fi
    - name: Test SCIM Groups endpoint
      runs: |
        # Create a test group
        CREATE_RESPONSE=$(curl -k -s -u "admin:admin" -X POST \
          -H "Content-Type: application/json" \
          -d '{
            "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
            "displayName": "testgroup123",
            "members": []
          }' \
          -w "\n%{http_code}" \
          "https://localhost:9443/scim2/Groups" 2>/dev/null)

        CREATE_CODE=$(echo "$CREATE_RESPONSE" | tail -1)
        CREATE_BODY=$(echo "$CREATE_RESPONSE" | head -n -1)

        if [ "$CREATE_CODE" != "201" ]; then
          echo "Failed to create SCIM group - HTTP $CREATE_CODE"
          echo "Response: $CREATE_BODY"; exit 1
        fi

        # List groups and verify our test group exists
        LIST_RESPONSE=$(curl -k -s -u "admin:admin" -w "\n%{http_code}" \
          "https://localhost:9443/scim2/Groups?filter=displayName+eq+testgroup123" 2>/dev/null)

        LIST_CODE=$(echo "$LIST_RESPONSE" | tail -1)
        LIST_BODY=$(echo "$LIST_RESPONSE" | head -n -1)

        if [ "$LIST_CODE" != "200" ]; then
          echo "Failed to list SCIM groups - HTTP $LIST_CODE"; exit 1
        fi

        # Verify the test group appears in the filtered results
        if ! echo "$LIST_BODY" | grep -q '"displayName".*"testgroup123"'; then
          echo "SCIM Groups test failed - created group not found in list"
          echo "Response: $LIST_BODY"; exit 1
        fi

update:
  enabled: true
  manual: true # Manual step required - details in 'vars' section.
  github:
    identifier: wso2/product-is
    strip-prefix: v
    tag-filter: v
